1. 数据同步加Redis
    通过消息队列进行数据同步到Redis,用Java去取缓存.
    优点: 分布式缓存,数据更新快.
    缺点: 依赖Redis稳定性.

2-3. Java Map到Guava cache
    进程内缓存作为一级缓存,Redis作为二级缓存.
    优点: 不受外部系统影响.
    缺点: 进程内缓存无法像分布式缓存那样做到实时更新.

4. Guava Cache刷新
    设置写后刷新时间,进行刷新.

5. 外部缓存异步刷新.

HashMap
    无法数据淘汰,内存会无限制增长.
    不需要淘汰机制时,使用HashMap做缓存.
LRUHashMap
    FIFO: 队列, 命中率不行.
    LRU: 最近最少使用算法, 每次访问数据放在队尾, 淘汰数据时直接淘汰队首. 不能保证热点数据存留.
    LFU: 最近最少频率使用, 利用额外的空间记录每个数据的使用频率,对频率最低的进行淘汰.

    实现LRUMap: 继承LinkedHashMap,重写removeEldestEntry方法.
    缺点: 锁竞争严重,不支持过期时间,不支持自动刷新.

Guava Cache
    分段锁: 锁太少竞争依然激烈, 锁太多会出现随机淘汰.根据一定的算法进行分段
    过期时间: expireAfterWrite 写后多久过期
             expireAfterAccess 读后多久过期
    虚引用: 两个引用队列, 记录被回收的引用，其中每个队列记录了每个被回收的Entry的hash，这样回收了之后通过这个队列中的hash值就能把以前的             Entry进行删除。
    删除监听器: 获取数据被淘汰的原因: 被用户删除, 被用户替代, 过期, 驱逐收集, 由于大小被淘汰.

Caffeine
    W-TinyLfu(LFU+LRU算法变种)
    LFU只要数据访问模式中的概率分布随时间保持不变,命中率就非常高. 但难以淘汰某些过去访问量高,但现在访问量低的数据.
    基于时间周期进行衰减,使用额外空间记录数据访问频率.

    频率记录
        Count-Min Sketch记录访问频率, 布隆过滤器的变种.

    异步读写
        使用RingBuffer