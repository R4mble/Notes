5.volatile
    缓存一致性协议: 保证了每个缓存中使用的共享变量的副本是一致的
        当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，
        会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，
        发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

    JMM: 并发编程的三个问题
        原子性问题
            一个操作或者多个操作,要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
        可见性问题
            当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
        有序性问题
            指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。

    Java对这三个问题的解决方案
        原子性
            Java内存模型只保证了基本读取和赋值是原子性操作,如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现

        可见性
            Java提供了volatile关键字来保证可见性.当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，
            当有其他线程需要读取时，它会去内存中读取新值。

            而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，
            当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

            通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，
            并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

        有序性
            通过volatile关键字来保证一定的“有序性”.  可以通过synchronized和Lock来保证有序性

            Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则
                程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
                锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作
                volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
                传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
                线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
                线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
                线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
                对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

    volatile关键字的两层语义
        保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
        禁止进行指令重排序。
        (不保证原子性)

            当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，
            且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

            在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，
            也不能把volatile变量后面的语句放到其前面执行。

    volatile的原理和实现机制
        加入volatile关键字时，会多出一个lock前缀指令
        lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
        　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
        　　2）它会强制将对缓存的修改操作立即写入主存；
        　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

    使用volatile关键字的场景
        对变量的写操作不依赖于当前值     该变量没有包含在具有其他变量的不变式中
            可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。



    synchronized和reentrantlock异同

        相同点
            都实现了多线程同步和内存可见性语义
            都是可重入锁
        不同点
            实现机制不同 
                synchronized通过java对象头锁标记和Monitor对象实现 
                synchronized依赖jvm内存模型保证包含共享变量的多线程内存可见性

                reentrantlock通过CAS、ASQ（AbstractQueuedSynchronizer）和locksupport（用于阻塞和解除阻塞）实现 
                reentrantlock通过ASQ的volatile state保证包含共享变量的多线程内存可见性

            使用方式不同 
                synchronized可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显式指定锁对象）
                reentrantlock显式调用trylock()/lock()方法，需要在finally块中释放锁

            功能丰富程度不同 
                reentrantlock提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供await、signal等方法）等丰富语义 
                reentrantlock提供公平锁和非公平锁实现 synchronized不可设置等待时间、不可被中断（interrupted）            